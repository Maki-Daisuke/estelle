# Estelle v2 Architecture Design Document

## 1. 概要 (Overview)

本ドキュメントは、画像サムネイルサーバー "estelle" のパフォーマンス改善およびアーキテクチャ刷新に関する設計仕様書である。
従来の「ファイル全読み込みによるハッシュ計算」から、「メタデータによるフィンガープリント」へ移行し、大規模ファイルセットに対する高速な応答性と、コンテナ環境における堅牢性を確保することを目的とする。

## 2. 主な変更点 (Key Changes)

| 機能           | 現行 (v1)                   | **改定後 (v2)**                                      |
| :---           | :---                        | :---                                                 |
| **変更検知**   | コンテンツハッシュ (SHA256) | **メタデータフィンガープリント**                     |
| **ID生成**     | コンテンツハッシュ値        | **メタデータハッシュ値**                             |
| **データ管理** | 単一ディレクトリ (Flat)     | **階層化ディレクトリ (Sharding)**                    |
| **同一性保証** | ファイルの中身 (Content)    | **パス + 属性 (Path + Attributes)**                  |
| **GC戦略**     | (未定義/全走査)             | **近似LRU (Random Sampling) + High/Low Watermark**   |

---

## 3. 詳細仕様 (Specification)

### 3.1. フィンガープリント (Fingerprint)

ファイルの変更検知およびキャッシュキー生成のために、以下のメタデータを使用する。
コンテナ環境でのDevID不安定問題や、エディタのAtomic SaveによるInode変更問題を回避するため、`Dev` および `Inode` は使用しない。

**構造体定義 (Go):**

```go
type Fingerprint struct {
    Path      string // ファイルパス (衝突防止のため必須)
    Size      int64  // ファイルサイズ (バイト)
    MtimeSec  int64  // 更新日時 (秒)
    MtimeNsec int64  // 更新日時 (ナノ秒) - Linux/Unix系での衝突回避に必須
}

```

> **Note:** Linuxでのナノ秒精度取得を推奨する。非対応ファイルシステム（FAT32等）では秒単位の変化しか検知できないため、短時間での連続更新時にキャッシュ更新漏れのリスクがあるが、動作自体は許容する。

### 3.2. ID生成アルゴリズム

フィンガープリント構造体の値を直列化し、SHA-256ハッシュを計算してID（Cache Key）とする。

* **衝突リスク:** パスを含めることで、異なるファイルが偶然同じサイズ・時刻を持っても別IDとなる。
* **重複:** 同一コンテンツのファイルが別パスに存在する場合、別々のID（キャッシュ）として生成されるが、ステートレス性維持のため許容する。

### 3.3. ストレージ構造 (Sharding)

ファイルシステムのスケーラビリティ確保と、ランダムサンプリングGCの効率化のため、ハッシュIDに基づいたディレクトリ階層化（Sharding）を行う。

* **フォーマット:** `ROOT/{head2}/{next2}/{full_id}-{width}x{height}-{overflow}.{ext}`
* **例:** IDが `a3f5c2...` の場合
* パス: `cache_dir/a3/f5/a3f5c2...-400x400-fill.jpg`

この構造により、トップレベルディレクトリのエントリ数を最大256個に抑え、各リーフディレクトリ内のファイル数も分散させる。

### 3.4. アクセス制御 (Access Control)

**セキュリティ要件:** 任意のファイル読み込み（LFI）および DoS 攻撃を防ぐため、起動時に指定された「許可ディレクトリ」以下の画像ファイルのみアクセスを許可する。

* **ホワイトリスト方式:** 起動引数で指定されたパス（およびそのサブディレクトリ）以外へのアクセスは `403 Forbidden` で拒否する。
* **正規化:** リクエストされたパスは `filepath.Clean` 等で正規化し、ディレクトリトラバーサル攻撃を防ぐ。

---

## 4. キャッシュ管理とGC (Cache Management)

データベース（SQLite等）を使用せず、ファイルシステムのみで完結するステートレスな管理を行う。

### 4.1. 容量管理 (Capacity Control)

起動時および実行時にキャッシュ容量を追跡する。容量制限およびGCの挙動は以下のCLI引数により制御する。

| 引数 | 説明 | デフォルト値 |
| :--- | :--- | :--- |
| `-l`, `--cache-limit` | キャッシュの最大容量制限。単位 (MB, GB) 対応。 | `1GB` |
| `--gc-high-ratio` | GCを開始する使用率（対 limit）。 | `0.90` (90%) |
| `--gc-low-ratio` | GCを停止する使用率（対 limit）。 | `0.75` (75%) |

1. **Startup:** 非同期で全キャッシュディレクトリをスキャンし、総容量を計算する。
2. **Runtime:** ファイル生成・削除のたびに、メモリ上のカウンター（Atomic Int64）を増減させる。

### 4.2. ガベージコレクション (GC) 戦略

「近似LRU (Approximated LRU)」を採用し、Stop-the-worldを回避する。

* **トリガー:** 総容量が **High Watermark** (例: 上限の90%) を超えた時。
* **停止条件:** 総容量が **Low Watermark** (例: 上限の75%) を下回るまで。
* **削除ロジック (Random Sampling):**

1. 第1階層 (`00`~`ff`)、第2階層のディレクトリからランダムに1つを選択する（Shardingの利点）。
2. 選択したディレクトリ内のファイルをスキャンする。
3. 最も **Atime (最終アクセス時刻)** が古いファイルを削除する。
4. Low Watermarkに達するまで繰り返す。

**一時ファイル掃除:**
GC実行時、または定期的な掃除タスクにおいて、一定時間以上更新されていない一時ファイル（ハッシュIDを持たない `.tmp` ファイル等）を削除し、不整合な残留ファイルを防ぐ。

### 4.3. Atimeの更新 (Lazy Touch)

OSの `relatime` / `noatime` 設定に依存せずLRUを機能させるため、アプリケーション側でAtimeを管理する。

* キャッシュヒット時、現在のAtimeが「現在時刻」より一定時間（例: 1時間）以上古い場合のみ、`os.Chtimes` を実行してAtimeを更新する。
* これにより、頻繁にアクセスされるファイルの削除を防ぎつつ、I/O負荷を抑制する。

---

## 5. 処理フロー概略 (Workflow)

### リクエスト受信時

1. リクエストされた元画像の `Fingerprint` (Path, Size, Mtime) を取得。
2. `ID` を計算。
3. `cache_dir/xx/yy/ID-{width}x{height}-{overflow}.{ext}` の存在を確認。

* **存在する場合 (HIT):**
* Lazy Touch判定を行い、必要ならAtime更新。
* ファイルを返却。

* **存在しない場合 (MISS):**
  * **キューイング:** サムネイル生成リクエストをサムネール生成キューに入れる。
  * **重複排除:** 同一IDへのリクエストが重複した場合、後続のリクエストは先行する生成タスクの完了を待機する（Thundering Herd対策）。これにより、重複生成によるレースコンディションとカウンターの不整合を防ぐ。
  * 元画像からサムネイル生成。
  * 一時ファイルとして書き込み、Atomic Renameで配置。
  * メモリ上の容量カウンターを加算。
  * High Watermarkを超えていれば、非同期でGCシグナルを発行。
  * ファイルを返却。

---

## 6. 考慮事項とトレードオフ (Trade-offs)

* **重複キャッシュの許容:** コンテンツハッシュを用いないため、リネームや別パス配置によりキャッシュが重複するが、DBレスによる堅牢性と実装の単純さを優先する。
* **コールドスタート:** サーバー再起動時の容量計算スキャン中は、正確な容量制限が機能しない可能性がある（許容範囲とする）。
